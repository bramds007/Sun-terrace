<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SunTerras â€” Amsterdam</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,body{height:100%;margin:0;font-family:-apple-system,system-ui,Segoe UI,Roboto,sans-serif}
    header{padding:10px 12px;border-bottom:1px solid #eee;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    #map{position:absolute;inset:72px 0 0 0}
    .badge{padding:4px 8px;border-radius:999px;background:#f5f5f5}
    .btn{padding:6px 10px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer}
  </style>
</head>
<body>
<header>
  <strong>SunTerras â€” AMS</strong>
  <span class="badge" id="info">Ladenâ€¦</span>
  <span class="badge" id="dataBadge">Data: ?</span>

  <label>Tijd: <input id="time" type="time" step="300"></label>
  <label>Datum: <input id="date" type="date"></label>
  <label><input id="onlySunny" type="checkbox"> alleen zon</label>
  <button class="btn" id="btnNow">Nu</button>
  <span class="badge" id="sunBadge">Zon: â€¦</span>
</header>
<div id="map"></div>

<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<script>
/* ===== Robuuste SunCalc (NOAA-achtig) â€” geeft altitude/azimuth in graden ===== */
function toRad(d){return d*Math.PI/180} function toDeg(r){return r*180/Math.PI}
function getJulian(date){return date/86400000 - date.getTimezoneOffset()/1440 + 2440587.5}
function solarMeanAnomaly(d){return toRad(357.5291 + 0.98560028*(d-2451545))}
function eclipticLongitude(M){
  const C = toRad(1.9148)*Math.sin(M)+toRad(0.02)*Math.sin(2*M)+toRad(0.0003)*Math.sin(3*M);
  const P = toRad(102.9372); // perihelion
  return M + C + P + Math.PI;
}
function sunCoords(d){
  const M = solarMeanAnomaly(d);
  const L = eclipticLongitude(M);
  const e = toRad(23.4397); // obliquity
  return {
    dec: Math.asin(Math.sin(e)*Math.sin(L)),
    ra: Math.atan2(Math.cos(e)*Math.sin(L), Math.cos(L))
  };
}
function siderealTime(d, lw){ return toRad((280.16 + 360.9856235*(d-2451545)))-lw; }
function sunPosition(date, lat, lon){
  const lw = toRad(-lon), phi = toRad(lat), d = getJulian(date) - 2451545;
  const c = sunCoords(d);
  const H = siderealTime(getJulian(date), lw) - c.ra;
  const alt = Math.asin(Math.sin(phi)*Math.sin(c.dec)+Math.cos(phi)*Math.cos(c.dec)*Math.cos(H));
  const az  = Math.atan2(Math.sin(H), Math.cos(H)*Math.sin(phi)-Math.tan(c.dec)*Math.cos(phi));
  return { altitude: toDeg(alt), azimuth: (toDeg(az)+180+360)%360 };
}
/* ============================================================================ */

const STATE = { date: new Date(), onlySunny: false, altThreshold: 2.5 };
let POLY_DATA = null, POINT_DATA = null; // we onthouden de GeoJSON zodat feature-state zeker werkt

// === Kaart ===
const map=new maplibregl.Map({
  container:'map',
  style:{version:8,
    sources:{osm:{type:'raster',tiles:['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],tileSize:256,attribution:'Â© OpenStreetMap'}},
    layers:[{id:'osm',type:'raster',source:'osm'}]},
  center:[4.895168,52.370216], zoom:13
});

map.on('load', init);

async function init(){
  const info=document.getElementById('info'), badge=document.getElementById('dataBadge');

  try{
    const r=await fetch('/api/terraces'); if(!r.ok) throw new Error('HTTP '+r.status);
    const data=await r.json();
    POLY_DATA  = data.terracePolys;
    POINT_DATA = data.placePoints;

    badge.textContent = `Data: ${data.source.toUpperCase()} â€¢ poly ${POLY_DATA.features.length} â€¢ pt ${POINT_DATA.features.length}`;
    info.textContent  = `${data.count} items`;

    // bronnen
    map.addSource('terr-polys',{ type:'geojson', data: POLY_DATA, promoteId: 'id' });
    map.addSource('terr-points',{ type:'geojson', data: POINT_DATA, promoteId: 'id' });

    // polygon (zon = groen, schaduw = grijs) via feature-state
    map.addLayer({ id:'terr-fill', type:'fill', source:'terr-polys',
      paint:{
        'fill-color':['case',['boolean',['feature-state','sunny'],false],'#22c55e','#cbd5e1'],
        // opacity wordt dynamisch gezet o.b.v. "alleen zon"
        'fill-opacity': 0.6
      }});
    map.addLayer({ id:'terr-outline', type:'line', source:'terr-polys',
      paint:{ 'line-color':'#111','line-width':1 }});

    // points fallback
    map.addLayer({ id:'terr-points', type:'circle', source:'terr-points',
      paint:{
        'circle-color':['case',['boolean',['feature-state','sunny'],false],'#22c55e','#cbd5e1'],
        'circle-opacity': 1.0, // wordt aangepast bij "alleen zon"
        'circle-radius':4,'circle-stroke-width':1,'circle-stroke-color':'#111'
      }});

    // labels
    map.addLayer({ id:'terr-label-polys', type:'symbol', source:'terr-polys',
      layout:{ 'text-field':['get','name'],'text-size':11,'text-offset':[0,1.0],'text-anchor':'top' },
      paint:{ 'text-halo-color':'#fff','text-halo-width':1.2 }});
    map.addLayer({ id:'terr-label-pts', type:'symbol', source:'terr-points',
      layout:{ 'text-field':['get','name'],'text-size':11,'text-offset':[0,1.0],'text-anchor':'top' },
      paint:{ 'text-halo-color':'#fff','text-halo-width':1.2 }});

    // popup
    function popup(e){
      const p=e.features[0].properties||{};
      new maplibregl.Popup().setLngLat(e.lngLat).setHTML(`<strong>${p.name||'Terras'}</strong>`).addTo(map);
    }
    map.on('click','terr-fill',popup);
    map.on('click','terr-points',popup);

    // fit naar data
    fitTo(POLY_DATA, POINT_DATA);

    // UI & zonkleur
    setupControls();     // zet inputs & listeners
    recomputeSunColors();// kleur direct
  }catch(e){
    info.textContent='Terrassen laden mislukt';
    badge.textContent='Data: ?';
    console.error(e);
  }
}

function fitTo(polys, points){
  const ex=[Infinity,Infinity,-Infinity,-Infinity];
  const bump=([x,y])=>{ if(x<ex[0])ex[0]=x; if(y<ex[1])ex[1]=y; if(x>ex[2])ex[2]=x; if(y>ex[3])ex[3]=y; };
  (polys.features||[]).forEach(f=>{
    const rings = f.geometry.type==='Polygon' ? [f.geometry.coordinates] : f.geometry.coordinates;
    rings.forEach(poly=>poly[0].forEach(bump));
  });
  (points.features||[]).forEach(f=> bump(f.geometry.coordinates));
  if(isFinite(ex[0])) map.fitBounds([[ex[0],ex[1]],[ex[2],ex[3]]],{padding:60,duration:600});
}

// Zet feature-state 'sunny' en pas laag-opacities aan (ipv filter)
function recomputeSunColors(){
  const AMS_LAT = 52.370216, AMS_LON = 4.895168;
  const sp = sunPosition(STATE.date, AMS_LAT, AMS_LON);
  const isSunny = sp.altitude > STATE.altThreshold;

  // feature-state zetten op basis van onze bewaarde data (zeker ids aanwezig)
  if (POLY_DATA)  POLY_DATA.features.forEach(f => map.setFeatureState({source:'terr-polys', id:f.id},{sunny:isSunny}));
  if (POINT_DATA) POINT_DATA.features.forEach(f => map.setFeatureState({source:'terr-points', id:f.id},{sunny:isSunny}));

  // â€œalleen zonâ€: maak schaduw transparant via opacity (filters kunnen geen feature-state lezen)
  if (STATE.onlySunny){
    map.setPaintProperty('terr-fill',   'fill-opacity',   ['case',['boolean',['feature-state','sunny'],false],0.6,0.0]);
    map.setPaintProperty('terr-points', 'circle-opacity', ['case',['boolean',['feature-state','sunny'],false],1.0,0.0]);
    // labels laten we staan; kan ook dicht als je wilt
  } else {
    map.setPaintProperty('terr-fill',   'fill-opacity', 0.6);
    map.setPaintProperty('terr-points', 'circle-opacity', 1.0);
  }

  // badge bijwerken
  const b=document.getElementById('sunBadge');
  if (b) b.textContent = `Zon: alt ${sp.altitude.toFixed(1)}Â° â€¢ az ${Math.round(sp.azimuth)}Â° â€¢ ${isSunny?'ðŸŒž':'â›…ï¸Ž'}`;
}

function setupControls(){
  const t=document.getElementById('time');
  const d=document.getElementById('date');
  const only=document.getElementById('onlySunny');
  const btnNow=document.getElementById('btnNow');

  // start bewust op 13:00 lokale tijd â†’ grote kans op zon
  const now=new Date();
  const pad=n=>String(n).padStart(2,'0');
  if (t) t.value = '13:00';
  if (d) d.valueAsDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  STATE.date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 13, 0);

  function updateDT(){
    const [hh,mm]=(t.value||'13:00').split(':').map(n=>parseInt(n,10));
    const base=d.valueAsDate||new Date();
    STATE.date = new Date(base.getFullYear(), base.getMonth(), base.getDate(), hh, mm);
    recomputeSunColors();
  }

  if (t) t.addEventListener('input', updateDT);
  if (d) d.addEventListener('input', updateDT);
  if (only) only.addEventListener('change', ()=>{ STATE.onlySunny = !!only.checked; recomputeSunColors(); });
  if (btnNow) btnNow.addEventListener('click', ()=>{
    const n=new Date();
    if (t) t.value = `${pad(n.getHours())}:${pad(n.getMinutes()-n.getMinutes()%5)}`;
    if (d) d.valueAsDate = new Date(n.getFullYear(), n.getMonth(), n.getDate());
    STATE.date = n;
    recomputeSunColors();
  });

  // eerste run is al gezet in init()
}
</script>
</body>
</html>
